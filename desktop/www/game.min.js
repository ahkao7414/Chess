// Chess Demo Code (Final Review - Incorporating RPS, AI Stub, Promotion, Game Over UI, jQuery 1.5.2 Compatibility: May 23, 2025)
(function(GameGlobal, $) {
    "use strict";

    // --- Storage Module ---
    GameGlobal.Storage = (function() {
        var storagePrefix = "chessdemo_";
        var gameLaunchedKey = storagePrefix + "gameLaunched";
        var gameDataKey = storagePrefix + "game";
        var appNeverLaunchedBefore = !localStorage.getItem(gameLaunchedKey);
        localStorage.setItem(gameLaunchedKey, "true");
        return {
            saveGame: function(gameData) { localStorage.setItem(gameDataKey, JSON.stringify(gameData)); },
            retrieveGame: function() { var gameString = localStorage.getItem(gameDataKey); return gameString ? JSON.parse(gameString) : null; },
            emptyGame: function() { localStorage.removeItem(gameDataKey); },
            hasGameSaved: function() { return !!localStorage.getItem(gameDataKey); },
            appNeverLaunched: function() { return appNeverLaunchedBefore; }
        };
    })();

    // --- Document Ready ---
    $(document).ready(function() {
        console.log("[DocumentReady] Document is ready, initializing Controller...");
        try { GameGlobal.Controller.init(); } catch (e) { console.error("[DocumentReady] CRITICAL ERROR during Controller.init():", e); alert("Critical error during Controller initialization. Check console."); return; }
        
        $(window).bind("hashchange", function() { 
            console.log("[HashChange] Hash changed to:", location.hash);
            try { GameGlobal.Controller.route(location.hash ? location.hash.replace("#!", "") : "/"); } catch (e) { console.error("[HashChange] CRITICAL ERROR during Controller.route():", e); alert("Critical error during routing. Check console.");}
        }).trigger("hashchange");

        $("a").each(function() {
            var link = $(this);
            if (link.attr("href") && link.attr("href").substring(0, 4) !== "http") {
                link.bind("click touchstart", function(e) { e.preventDefault(); location.hash = $(this).attr("href"); });
            }
        });
        setTimeout(function() { $("#pages").addClass("enabletransition"); console.log("[DocumentReady] Transition enabled.")}, 500);

        // --- BACKGROUND MUSIC LOGIC ---
        var backgroundMusic = document.getElementById("backgroundMusic");
        var musicToggleButton = $("#musicToggleButton"); // Assumes button ID in HTML
        var musicPlaying = false;
        var userHasInteracted = false; // Track if user has interacted for autoplay policy

        function playMusic() {
            if (backgroundMusic && backgroundMusic.paused) {
                // Ensure volume is not 0 if it was muted before.
                if (backgroundMusic.volume === 0) backgroundMusic.volume = 0.5; // Default volume if muted
                
                backgroundMusic.play()
                    .then(function() {
                        console.log("[Music] Background music started playing.");
                        musicPlaying = true;
                        if (musicToggleButton.length) musicToggleButton.text("暫停音樂");
                    })
                    .catch(function(error) {
                        console.warn("[Music] Music play failed (possibly due to browser policy until interaction, or error):", error);
                        musicPlaying = false;
                        if (musicToggleButton.length) musicToggleButton.text("播放音樂");
                    });
            } else if (backgroundMusic && !backgroundMusic.paused) {
                // Already playing, ensure button text is correct
                 if (musicToggleButton.length) musicToggleButton.text("暫停音樂");
            }
        }

        function pauseMusic() {
            if (backgroundMusic && !backgroundMusic.paused) {
                backgroundMusic.pause();
                // musicPlaying will be set to false by the 'pause' event listener
                // if (musicToggleButton.length) musicToggleButton.text("播放音樂");
                console.log("[Music] Background music paused by function call.");
            }
        }
        
        GameGlobal.tryPlayMusic = function() {
            if (!userHasInteracted) { 
                userHasInteracted = true; 
                console.log("[Music] First user interaction for music registered via tryPlayMusic.");
            }
            if(backgroundMusic && backgroundMusic.readyState >= 2) { // HAVE_CURRENT_DATA or more
                 console.log("[Music] tryPlayMusic: Music ready, attempting play.");
                 playMusic();
            } else if (backgroundMusic) {
                console.log("[Music] tryPlayMusic: Music not ready yet, will try once 'canplaythrough' event fires.");
                // Use a namespaced event to easily unbind it later if needed.
                $(backgroundMusic).unbind('canplaythrough.initialMusicPlay').bind('canplaythrough.initialMusicPlay', function() { 
                    console.log("[Music] Music 'canplaythrough' event fired after tryPlayMusic.");
                    $(this).unbind('canplaythrough.initialMusicPlay'); 
                    playMusic();
                });
            } else {
                console.warn("[Music] tryPlayMusic: backgroundMusic element not found.");
            }
        };

        if (backgroundMusic) { // Only set up listeners if the audio element exists
            // Event listeners for the audio element itself to update button text and state
            $(backgroundMusic).bind("play", function() {
                console.log("[Music] Event: play");
                musicPlaying = true;
                if (musicToggleButton.length) musicToggleButton.text("暫停音樂");
            });
            $(backgroundMusic).bind("pause", function() {
                console.log("[Music] Event: pause");
                musicPlaying = false;
                if (musicToggleButton.length) musicToggleButton.text("播放音樂");
            });
            $(backgroundMusic).bind("ended", function() { 
                console.log("[Music] Event: ended (loop should restart if 'loop' attribute is present).");
                musicPlaying = false; 
                if (musicToggleButton.length) musicToggleButton.text("播放音樂");
                // If `loop` attribute is on the audio tag, it should handle looping.
                // Otherwise, you could call backgroundMusic.play() here.
            });

            if (musicToggleButton.length) {
                musicToggleButton.bind("click", function() {
                    if (!userHasInteracted) {
                        userHasInteracted = true; 
                        console.log("[Music] First user interaction via toggle button.");
                    }
                    if (musicPlaying) {
                        pauseMusic();
                    } else {
                        playMusic(); // This will attempt to play
                    }
                });
            } else {
                console.warn("[Music] Music toggle button #musicToggleButton not found.");
            }
        } else {
            console.warn("[Music] Audio element #backgroundMusic not found.");
        }
        // --- END BACKGROUND MUSIC LOGIC ---
    });

    GameGlobal.currentGame = null;
    GameGlobal.humanPlayerIsWhite = true; 

    // --- Controller Module ---
    GameGlobal.Controller = (function() {
        var changePage = function(pageId) {
            console.log("[Controller] Attempting to change page to:", pageId);
            var targetPage = $("#" + pageId);
            if (targetPage.length === 0) { console.error("[Controller] Page not found for ID:", pageId); return; }
            targetPage.siblings().removeClass("current"); 
            targetPage.addClass("current");
            console.log("[Controller] #" + pageId + " is now current. Classes:", targetPage.attr('class'));
        };
        var routeChangeListeners=[]; var executeRouteChangeListeners=function(){for(var i=0;i<routeChangeListeners.length;++i){try{routeChangeListeners[i]()}catch(e){console.error("[Controller] Error in RCL:",e)}}routeChangeListeners=[]};
        
        function handleRPSChoice(playerChoice) {
            console.log("[Controller] RPS: Player chose", playerChoice);
            var choices = ["rock", "paper", "scissors"];
            var choiceText = {"rock": "石頭", "paper": "布", "scissors": "剪刀"};
            var computerChoice = choices[Math.floor(Math.random() * choices.length)];
            var resultText = "";
            var playerWonRPS = false;
            var tie = false;

            $("#rps-message").html("你出了: " + choiceText[playerChoice] + "<br>電腦出了: " + choiceText[computerChoice]);
            $("#rps-options button").attr("disabled", "disabled"); 

            if (playerChoice === computerChoice) {
                resultText = "平手！";
                tie = true;
            } else if ((playerChoice === "rock" && computerChoice === "scissors") || (playerChoice === "paper" && computerChoice === "rock") || (playerChoice === "scissors" && computerChoice === "paper")) {
                resultText = "你贏了猜拳！";
                playerWonRPS = true;
            } else {
                resultText = "電腦贏了猜拳！";
                playerWonRPS = false;
            }
            $("#rps-result").text(resultText);
            console.log("[Controller] RPS Result:", resultText);

            if (playerWonRPS) {
                $("#rps-message").append("<br>請選擇你要執的棋子顏色。");
                $("#color-selection").show();
                $("#start-game-container").hide(); 
                console.log("[Controller] RPS: Player won, showing color selection.");
            } else if (tie) {
                $("#rps-message").append("<br>平手了，請再試一次！");
                $("#color-selection").hide();
                $("#start-game-container").hide();
                setTimeout(function() { 
                    $("#rps-options button").removeAttr("disabled"); 
                    $("#rps-result").empty(); $("#rps-message").empty();
                    console.log("[Controller] RPS: Tie, resetting for another try.");
                }, 1500);
            } else { // Computer won RPS
                GameGlobal.humanPlayerIsWhite = Math.random() < 0.5; 
                var msg = GameGlobal.humanPlayerIsWhite ? "<br>電腦讓你執白。" : "<br>電腦決定讓你執黑 (它執白先走)。";
                $("#rps-message").append(msg);
                console.log("[Controller] RPS: Computer won.", msg.replace("<br>"," "));
                $("#color-selection").hide();
                $("#start-game-container").show(); 
                console.log("[Controller] RPS: Showing start game container. Visible:", $("#start-game-container").is(":visible"));
            }
        }
        
        return {
            init: function() { console.log("[Controller] Initialized."); },
            route: function(path) {
                console.log("[Controller] Routing to path:", path);
                executeRouteChangeListeners();
                if (path === "/") return this.index();
                if (path === "/menu") return this.menu();
                if (path === "/game/new") return this.rpsGame(); 
                if (path === "/rps") return this.rpsGame();    
                if (path === "/game/continue") return this.continueGame();
                if (path === "/game") { console.log("[Controller] Matched /game route."); return this.game(); }
                if (path === "/help") return this.help();
                console.log("[Controller] No specific route for '"+path+"', defaulting to menu."); return this.menu();
            },
            index: function(){return this.menu()},
            menu: function(){console.log("[Controller] menu()");if(GameGlobal.currentGame||GameGlobal.Storage.hasGameSaved()){$(".showOnlyIfContinuableGame").show()}else{$(".showOnlyIfContinuableGame").hide()}changePage("menu")},
            continueGame: function(){
                console.log("[Controller] continueGame()");
                if(!GameGlobal.currentGame && GameGlobal.Storage.hasGameSaved()){
                    var savedGameData=GameGlobal.Storage.retrieveGame();
                    if(savedGameData){
                        GameGlobal.currentGame=new GameGlobal.Game(savedGameData); 
                        if (GameGlobal.currentGame.aiPlayerColor) { 
                           GameGlobal.humanPlayerIsWhite = (GameGlobal.currentGame.aiPlayerColor === "black");
                        } else { 
                           GameGlobal.humanPlayerIsWhite = (GameGlobal.currentGame.currentPlayer === "white"); 
                        }
                        console.log("[Controller] Game continued from storage. Human is white:", GameGlobal.humanPlayerIsWhite);
                    } else { GameGlobal.Storage.emptyGame(); location.hash = "#!/rps"; return; }
                } else if (!GameGlobal.currentGame) { location.hash = "#!/rps"; return; }
                return this.game(); 
            },
            newGame: function(){ console.log("[Controller] newGame() called, routing to RPS game."); location.hash = "#!/rps"; },
            rpsGame: function() {
                console.log("[Controller] rpsGame() page displayed/re-initialized.");
                changePage("rps-game"); 
                $("#rps-options button").removeAttr("disabled").unbind("click").bind("click", function() {var choice = $(this).data("choice"); handleRPSChoice(choice);});
                $("#choose-white").unbind("click").bind("click", function() {console.log("[Controller] RPS: Chose to play White."); GameGlobal.humanPlayerIsWhite = true; GameGlobal.Controller.startGameAfterSelection();});
                $("#choose-black").unbind("click").bind("click", function() {console.log("[Controller] RPS: Chose to play Black."); GameGlobal.humanPlayerIsWhite = false; GameGlobal.Controller.startGameAfterSelection();});
                $("#start-chess-game").unbind("click").bind("click", function() { console.log("[Controller] RPS: #start-chess-game button clicked."); GameGlobal.Controller.startGameAfterSelection();});
                $("#rps-result").empty(); $("#rps-message").empty(); $("#color-selection").hide(); $("#start-game-container").hide();
                console.log("[Controller] RPS UI reset.");
            },
            startGameAfterSelection: function() {
                console.log("[Controller] startGameAfterSelection(). Human will play as white:", GameGlobal.humanPlayerIsWhite);
                GameGlobal.Storage.emptyGame(); GameGlobal.currentGame = null; location.hash = "#!/game"; 
            },
            game: function() {
                console.log("[Controller] game() method started.");
                var renderer; var gameInstance;
                try{renderer=new GameGlobal.Renderer();console.log("[Controller] Renderer instance created.")}catch(e){console.error("[Controller] CRITICAL: Failed creating Renderer instance:",e);alert("Error creating renderer. Check console.");return}
                
                if(!GameGlobal.currentGame){
                    try{
                        GameGlobal.currentGame=(new GameGlobal.Game()).init(GameGlobal.humanPlayerIsWhite); 
                        console.log("[Controller] New Game instance initialized for game screen. Human plays white:", GameGlobal.humanPlayerIsWhite);
                    }catch(e){console.error("[Controller] CRITICAL: Failed initializing new Game instance:",e);alert("Error initializing game. Check console.");return}
                }
                gameInstance = GameGlobal.currentGame;
                if (!gameInstance) { console.error("[Controller] CRITICAL: gameInstance is null before renderer.init().");alert("Critical error: Game instance not available. Check console.");return;}
                gameInstance.renderer = renderer; 
                
                try{renderer.init(gameInstance);console.log("[Controller] Renderer initialized.")}catch(e){console.error("[Controller] CRITICAL: Failed initializing Renderer with game instance:",e);alert("Error initializing renderer with game. Check console.");return}
                
                gameInstance.bindChange(function(){
                    GameGlobal.Storage.saveGame(gameInstance.export());
                    if(gameInstance.isFinished()){
                        GameGlobal.Controller.showGameOverUI(gameInstance); 
                    } else {
                        if (gameInstance.currentPlayer === gameInstance.aiPlayerColor && 
                            !gameInstance.isAIMoving && 
                            typeof GameGlobal.AIEngine !== 'undefined' && 
                            typeof GameGlobal.AIEngine.chooseMove === 'function') {
                            gameInstance.makeAIMove();
                        }
                    }
                });
                console.log("[Controller] Calling changePage('game').");
                changePage("game");
                if(gameInstance.currentPlayer === gameInstance.aiPlayerColor && !gameInstance.isFinished() && !gameInstance.isAIMoving){console.log("[Controller] game(): AI's turn post-setup. Triggering AI.");gameInstance.makeAIMove()}
                console.log("[Controller] game() method finished.");
            },
            showGameOverUI: function(gameInstance) {
                var winner = gameInstance.winner;
                var detailedMessage = gameInstance.gameOverMessage || "遊戲結束！"; 
                var genericTitle = "遊戲結束！";
                var imagePath = "images/game_over_generic.png"; 

                if (winner) { 
                    var humanColor = GameGlobal.humanPlayerIsWhite ? "white" : "black";
                    var aiColor = gameInstance.aiPlayerColor || (humanColor === "white" ? "black" : "white");
                    if (winner === humanColor) {
                        genericTitle = "恭喜你，你贏了！"; imagePath = "images/player_wins.png"; 
                        console.log("[Controller] Game Over: Player (" + humanColor + ") wins.");
                    } else if (winner === aiColor) { 
                        genericTitle = "再接再厲！"; imagePath = "images/ai_wins.png"; 
                        console.log("[Controller] Game Over: AI (" + aiColor + ") wins.");
                    } else { console.log("[Controller] Game Over: Winner is", winner, "but couldn't determine if player or AI.");}
                } else { console.log("[Controller] Game Over: No specific winner (e.g. draw)."); }
                
                console.log("[Controller] Showing Game Over UI. Title:", genericTitle, "Message:", detailedMessage, "Image:", imagePath);
                $("#gameOverTitle").text(genericTitle); 
                $("#gameOverImage").attr("src", imagePath); 
                $("#gameOverMessageText").text(detailedMessage); 
                $("#gameOverPopup").css("display", "flex"); 

                $("#gameOverCloseButton").unbind("click").bind("click", function() {
                    console.log("[Controller] Game Over UI closed.");
                    $("#gameOverPopup").hide();
                    if (GameGlobal.currentGame && GameGlobal.currentGame.renderer) { delete GameGlobal.currentGame.renderer;}
                    GameGlobal.currentGame = null;
                    location.hash = "#!/menu"; 
                });
            },
            help: function(){console.log("[Controller] help()");changePage("help")}
        };
    })();

    var pubSub=(function(){var topics={};return{pub:function(topic,data){if(!topics[topic]){return}var subscribers=topics[topic];for(var i=0;i<subscribers.length;++i){subscribers[i](data)}},sub:function(topic,callback){if(!topics[topic]){topics[topic]=[]}topics[topic].push(callback)}}})();
    var uniqueId=(function(){var id=0;return function(){return++id}})();
    var forEachSquare=function(callback){_.each("87654321",function(rank){_.each("abcdefgh",function(file){callback(file+rank,file,rank)})})};
    var algebraicToCoords=function(algebraicPos){return{x:algebraicPos.charCodeAt(0)-97,y:parseInt(algebraicPos.substring(1,2))-1}};
    var coordsToAlgebraic=function(coords){return String.fromCharCode(coords.x+97)+(coords.y+1)};
    var createPieceImage=function(piece){return $('<img src="images/'+piece.color+"_"+piece.type+'.png" alt="'+piece.color+' '+piece.type+'" />')};

    if (typeof GameGlobal.AIEngine === 'undefined') { GameGlobal.AIEngine = { chooseMove: function(gameInstance) { console.log("[AIEngine] AI (" + gameInstance.currentPlayer + ") choosing move...");var aiColor = gameInstance.currentPlayer;var allMyPieces = _.filter(gameInstance.pieces, function(p) { return p.color === aiColor; });var possibleAIMoves = [];_.each(allMyPieces, function(piece) {var moves = gameInstance.getMoves(piece, gameInstance.generateCurrentMap());_.each(moves, function(targetSquare) {possibleAIMoves.push({ piece: piece, from: piece.position, to: targetSquare });});});if (possibleAIMoves.length > 0) {var randomIndex = Math.floor(Math.random() * possibleAIMoves.length);var chosenMove = possibleAIMoves[randomIndex];console.log("[AIEngine] AI chose:", chosenMove.piece.type, chosenMove.from, "->", chosenMove.to);return chosenMove;} else {console.log("[AIEngine] AI no moves."); return null;}}};}

    GameGlobal.Renderer = function() {
        var self = this;
        var lightSquares = ["a2","a4","a6","a8","c2","c4","c6","c8","e2","e4","e6","e8","g2","g4","g6","g8","b1","b3","b5","b7","d1","d3","d5","d7","f1","f3","f5","f7","h1","h3","h5","h7"];
        self.showPromotionDialog = function(playerColor, onPromoteCallback) {var pieceInput=null,chosenType="queen",validInput=!1,promptMessage="Pawn Promotion!\nEnter: 'q' (Queen), 'r' (Rook), 'b' (Bishop), 'k' (Knight)";while(!validInput){pieceInput=window.prompt(promptMessage,"q");if(pieceInput===null){chosenType="queen";validInput=!0;console.log("[Renderer] Promo cancelled, defaulting to Queen.")}else{pieceInput=pieceInput.trim().toLowerCase();if(pieceInput==="q"){chosenType="queen";validInput=!0}else if(pieceInput==="r"){chosenType="rook";validInput=!0}else if(pieceInput==="b"){chosenType="bishop";validInput=!0}else if(pieceInput==="k"){chosenType="knight";validInput=!0}else{alert("Invalid: '"+pieceInput+"'.")}}}console.log("[Renderer] Promoted to:",chosenType);onPromoteCallback(chosenType)};
        self.render = function() {if(!self.game||!self.boardElement||!self.positions||Object.keys(self.positions).length===0){console.warn("[Renderer] Render too early.");return}self.boardElement[0].className="player-"+self.game.currentPlayer;var currentBoardMap=self.game.generateCurrentMap();forEachSquare(function(algebraicPos){var pieceOnSquare=currentBoardMap[algebraicPos];var className=algebraicPos;if(_.include(lightSquares,algebraicPos)){className+=" lighter"}if(pieceOnSquare){className+=" piece "+pieceOnSquare.color+" "+pieceOnSquare.type;if(self.game.currentPiece===pieceOnSquare){className+=" current"}}if(self.game.possibleMoveContains(algebraicPos)){className+=" playable"}if(self.positions[algebraicPos]){self.positions[algebraicPos].className=className}});self.blackEatedElement.empty();_.each(self.game.blackEated,function(pieceType){self.blackEatedElement.append(createPieceImage({color:"white",type:pieceType}))});self.whiteEatedElement.empty();_.each(self.game.whiteEated,function(pieceType){self.whiteEatedElement.append(createPieceImage({color:"black",type:pieceType}))});};
        self.init = function(gameInstance) {console.log("[Renderer] Initializing...");self.game=gameInstance;self.boardElement=$("#chessboard");self.blackEatedElement=$("#black-eated");self.whiteEatedElement=$("#white-eated");if(self.boardElement.length===0){console.error("[Renderer] CRITICAL: #chessboard missing!");return this}self.boardElement.empty();self.positions={};forEachSquare(function(algebraicPos){var squareDiv=$("<div />");self.positions[algebraicPos]=squareDiv[0];self.boardElement.append(squareDiv);squareDiv.bind("click",function(){if(!self.game.isFinished()&&!self.game.isAwaitingPawnPromotion){self.game.onClick(algebraicPos)}})});self.render();self.game.bindChange(self.render.bind(self));console.log("[Renderer] Initialized.");return this};
    };

    GameGlobal.Piece = function(config){this.color=config.color;this.type=config.type;this.position=config.position;};

    GameGlobal.Game = function(savedGameData) {
        var self = this;
        self.pieces = []; self.whiteEated = []; self.blackEated = []; self.currentPlayer = "white";
        self.currentPiece = null; self.possibleMoves = null; self.winner = null; self.gameOverMessage = "";
        self.isAwaitingPawnPromotion = false; self.pawnThatReachedEnd = null; self.afterPromotionAction = null;
        self.aiPlayerColor = "black"; self.isAIMoving = false;

        var gameChangeEventName = "game"+uniqueId()+"_change";

        self.import = function(dataToImport) { 
            self.pieces=_.map(dataToImport.pieces,function(p){return new GameGlobal.Piece(p)});
            self.whiteEated=_.clone(dataToImport.whiteEated);self.blackEated=_.clone(dataToImport.blackEated);
            self.currentPlayer=dataToImport.currentPlayer;self.winner=dataToImport.winner||null;
            self.gameOverMessage=dataToImport.gameOverMessage||"";
            self.aiPlayerColor=dataToImport.aiPlayerColor||"black"; 
            GameGlobal.humanPlayerIsWhite = (self.aiPlayerColor === "black"); 
            self.isAIMoving=dataToImport.isAIMoving||false; 
            console.log("[Game] Game imported. Player:", self.currentPlayer, "AI:", self.aiPlayerColor, "HumanWhite:", GameGlobal.humanPlayerIsWhite);
        };
        
        self.init = function(isHumanPlayingWhite = true) { 
            console.log("[Game] init() called. isHumanPlayingWhite:", isHumanPlayingWhite);
            var createPiece=function(color,type,position){return new GameGlobal.Piece({color:color,type:type,position:position})};
            self.pieces=[]; self.currentPiece=null;self.possibleMoves=[];
            self.whiteEated=[];self.blackEated=[];self.winner=null;self.gameOverMessage="";
            self.isAwaitingPawnPromotion=false;self.pawnThatReachedEnd=null;self.afterPromotionAction=null;
            self.isAIMoving=false;

            if (isHumanPlayingWhite) { 
                self.currentPlayer = "white"; 
                self.aiPlayerColor = "black";
            } else { 
                self.currentPlayer = "white"; 
                self.aiPlayerColor = "white";
            }
            console.log("[Game] New game setup: Human plays white:", isHumanPlayingWhite, "-> Current player (starts):", self.currentPlayer, "| AI plays as:", self.aiPlayerColor);
            
            var initialSetup=["rook","knight","bishop","queen","king","bishop","knight","rook"];
            for(var i=0;i<=7;++i){var file=String.fromCharCode(i+97);
                self.pieces.push(createPiece("white",initialSetup[i],file+"1"));
                self.pieces.push(createPiece("white","pawn",file+"2"));
                self.pieces.push(createPiece("black","pawn",file+"7"));
                self.pieces.push(createPiece("black",initialSetup[i],file+"8"));
            }
            console.log("[Game] Pieces placed for new game.");
            // self.triggerChange(); // Controller will check if AI needs to move after page load.
            return self;
        };

        if(savedGameData){ 
            self.import(savedGameData);
        }
        // If no savedGameData, Controller will call init() when a new game is started.
        
        self.export = function(){return{pieces:_.map(self.pieces,function(p){return{color:p.color,type:p.type,position:p.position}}),whiteEated:_.clone(self.whiteEated),blackEated:_.clone(self.blackEated),currentPlayer:self.currentPlayer,winner:self.winner,gameOverMessage:self.gameOverMessage,aiPlayerColor:self.aiPlayerColor,isAIMoving:self.isAIMoving}};
        self.toggleCurrentPlayer = function(){self.currentPlayer=(self.currentPlayer=="white")?"black":"white"; console.log("[Game] Current player toggled to:", self.currentPlayer);};
        self.triggerChange = function(){console.log("[Game] Triggering change event:",gameChangeEventName);pubSub.pub(gameChangeEventName,self);};
        self.bindChange = function(callback){pubSub.sub(gameChangeEventName,callback);};
        self.onClick = function(algebraicPos) {
            console.log("%c[Game] onClick. Pos:" + algebraicPos + ", Player:" + self.currentPlayer + ", Selected:" + (self.currentPiece?self.currentPiece.type + "@" + self.currentPiece.position:"None") + ", PromoWait:" + self.isAwaitingPawnPromotion, "color:blue;font-weight:bold;");
            if (self.isFinished()){console.log("[Game] onClick ignored: Game finished."); return;}
            if (self.isAwaitingPawnPromotion){console.log("[Game] onClick ignored: Awaiting promo."); return;}
            if (self.currentPlayer === self.aiPlayerColor && !self.isAIMoving){console.log("[Game] onClick ignored: AI's turn."); return;}

            var unselectAndNotify = function(){self.unselect();self.triggerChange();};
            var selectAndNotify = function(pieceToSelect){self.select(pieceToSelect);self.triggerChange();};
            var completeTurnSequence = function(){console.log("[Game] Human onClick: Executing completeTurnSequence.");self.unselect();self.toggleCurrentPlayer();self.triggerChange();};
            
            var pieceAtClickedSquare = self.findPieceByPosition(algebraicPos);
            var isCurrentPlayerPiece = pieceAtClickedSquare && pieceAtClickedSquare.color == self.currentPlayer;
            var isOpponentPiece = pieceAtClickedSquare && pieceAtClickedSquare.color != self.currentPlayer;
            var actionTaken = false;

            if(self.currentPiece){
                if(isCurrentPlayerPiece){if(pieceAtClickedSquare===self.currentPiece){unselectAndNotify()}else{selectAndNotify(pieceAtClickedSquare)}}
                else if(isOpponentPiece){if(self.canTakeWithSelected(pieceAtClickedSquare)){self.takeWithSelected(pieceAtClickedSquare);actionTaken=true}else{unselectAndNotify()}}
                else{if(self.canMoveSelected(algebraicPos)){self.moveSelected(algebraicPos);actionTaken=true}else{unselectAndNotify()}}
                if(actionTaken){
                    console.log("[Game] onClick Human: Action taken. Piece:",self.currentPiece.type,"@",self.currentPiece.position);
                    if(self.winner){console.log("[Game] onClick Human: King captured. Winner:",self.winner);completeTurnSequence();return}
                    var pawnMoved=self.currentPiece;var pawnToPromoteDetails=self.checkPawnPromotion(pawnMoved);
                    if(pawnToPromoteDetails.needsPromotion){console.log("[Game] onClick Human: Pawn promo needed @",pawnMoved.position);self.initiatePawnPromotion(pawnToPromoteDetails.pawn,completeTurnSequence);return}
                    else{console.log("[Game] onClick Human: No promo. Completing turn.");completeTurnSequence()}
                }
            }else{if(isCurrentPlayerPiece){selectAndNotify(pieceAtClickedSquare)}}
        };
        self.makeAIMove = function() {
            if(self.isFinished()||self.currentPlayer!==self.aiPlayerColor||self.isAIMoving){if(self.isAIMoving)console.warn("[Game] AI already moving.");if(self.isFinished())console.log("[Game] makeAIMove: Game finished.");if(self.currentPlayer!==self.aiPlayerColor)console.log("[Game] makeAIMove: Not AI's turn.");return}
            console.log("[Game] makeAIMove: AI's turn ("+self.aiPlayerColor+").");self.isAIMoving=true;
            setTimeout(function(){
                var aiChosenMove=GameGlobal.AIEngine.chooseMove(self);
                if(aiChosenMove&&aiChosenMove.piece&&aiChosenMove.to){
                    var pieceToMove=self.findPieceByPosition(aiChosenMove.piece.position);
                    if(!pieceToMove||pieceToMove.color!==self.aiPlayerColor){console.error("[Game] AI invalid piece choice:",aiChosenMove, "Found:", pieceToMove);self.isAIMoving=false;self.toggleCurrentPlayer();self.triggerChange();return}
                    self.currentPiece=pieceToMove;self.possibleMoves=self.getMoves(self.currentPiece,self.generateCurrentMap());
                    var targetSquare=aiChosenMove.to;var pieceAtTarget=self.findPieceByPosition(targetSquare);var actionTaken=false; 
                    console.log("[Game] AI trying:",self.currentPiece.type,"@",self.currentPiece.position,"->",targetSquare, "Possible moves:", JSON.stringify(self.possibleMoves));
                    if(pieceAtTarget&&pieceAtTarget.color!==self.currentPlayer){if(self.canTakeWithSelected(pieceAtTarget)){console.log("[Game] AI taking:",pieceAtTarget.type,"@",targetSquare);self.takeWithSelected(pieceAtTarget);actionTaken=true}else{console.error("[Game] AI invalid capture:",aiChosenMove,"Moves for",self.currentPiece.type,":",JSON.stringify(self.possibleMoves))}}
                    else if(!pieceAtTarget){if(self.canMoveSelected(targetSquare)){console.log("[Game] AI moving to empty:",targetSquare);self.moveSelected(targetSquare);actionTaken=true}else{console.error("[Game] AI invalid move to empty:",aiChosenMove,"Moves for",self.currentPiece.type,":",JSON.stringify(self.possibleMoves))}}
                    else{console.error("[Game] AI invalid target (own piece?):",aiChosenMove)}
                    var completeAITurnSequence=function(){console.log("[Game] Completing AI turn.");self.unselect();self.toggleCurrentPlayer();self.isAIMoving=false;self.triggerChange()};
                    if(actionTaken){
                        console.log("[Game] AI action taken. Piece:",self.currentPiece.type,"@",self.currentPiece.position);
                        if(self.winner){console.log("[Game] AI move caused game end. Winner:",self.winner);completeAITurnSequence();return}
                        var pawnPromotedDetails=self.checkPawnPromotion(self.currentPiece);
                        if(pawnPromotedDetails.needsPromotion){console.log("[Game] AI pawn promo.");var aiPromotedPieceType="queen";self.pawnThatReachedEnd=pawnPromotedDetails.pawn;self.finalizePawnPromotion(aiPromotedPieceType);console.log("[Game] AI pawn promoted. Completing turn.");completeAITurnSequence()}
                        else{completeAITurnSequence()}
                    }else{console.error("[AI] AI failed valid action:",aiChosenMove,". Skipping AI turn.");self.unselect();self.isAIMoving=false;self.toggleCurrentPlayer();self.triggerChange()}
                }else{console.log("[Game] AI no moves (checkmate or stalemate by human).");self.unselect();self.isAIMoving=false;self.triggerChange()} 
            },500)
        };
        self.select = function(pieceToSelect){self.currentPiece=pieceToSelect;self.possibleMoves=self.getMoves(pieceToSelect);console.log("[Game] Selected piece:",pieceToSelect.type,"@",pieceToSelect.position,"| Possible moves:",JSON.stringify(self.possibleMoves));};
        self.unselect = function(){self.currentPiece=null;self.possibleMoves=null; console.log("[Game] Piece unselected.");};
        self.possibleMoveContains = function(algebraicPos){return self.possibleMoves&&_.include(self.possibleMoves,algebraicPos);};
        self.canTakeWithSelected = function(targetPiece) {var canTake = self.currentPiece && self.possibleMoves && self.possibleMoveContains(targetPiece.position);console.log("[Game] canTakeWithSelected (",(self.currentPiece?self.currentPiece.type:"N/A"),"->",targetPiece.type,"@",targetPiece.position,")? Result:",canTake,"PossibleMoves:",JSON.stringify(self.possibleMoves));return canTake;};
        self.canMoveSelected = function(targetAlgebraicPos){return!self.findPieceByPosition(targetAlgebraicPos)&&self.possibleMoveContains(targetAlgebraicPos);};
        self.checkPawnPromotion = function(movedPiece){if(movedPiece&&movedPiece.type==="pawn"){var currentPawnCoords=algebraicToCoords(movedPiece.position);var promotionRank=(movedPiece.color==="white")?7:0;if(currentPawnCoords.y===promotionRank){console.log("[Game] Pawn at promotion rank. Needs promotion.");return{needsPromotion:!0,pawn:movedPiece}}}return{needsPromotion:!1,pawn:null}};
        self.initiatePawnPromotion = function(pawn, actionAfterPromotion){console.log("[Game] Initiating HUMAN pawn promotion for pawn at",pawn.position);self.isAwaitingPawnPromotion=!0;self.pawnThatReachedEnd=pawn;self.afterPromotionAction=actionAfterPromotion;if(self.renderer&&typeof self.renderer.showPromotionDialog==='function'){self.renderer.showPromotionDialog(pawn.color,function(chosenType){self.finalizePawnPromotion(chosenType)})}else{console.error("[Game] Renderer or showPromotionDialog not available. Auto-promoting to Queen.");self.finalizePawnPromotion("queen")}};
        self.finalizePawnPromotion = function(chosenType){console.log("[Game] Finalizing pawn promotion. Pawn to promote was:",self.pawnThatReachedEnd?self.pawnThatReachedEnd.type+"@"+self.pawnThatReachedEnd.position:"null","| Chosen type:",chosenType);if(self.pawnThatReachedEnd){console.log("[Game] Before type change for piece at "+self.pawnThatReachedEnd.position+": Type was "+self.pawnThatReachedEnd.type);self.pawnThatReachedEnd.type=chosenType;console.log("[Game] After type change for piece at "+self.pawnThatReachedEnd.position+": Type is now "+self.pawnThatReachedEnd.type)}else{console.error("[Game] finalizePawnPromotion called but pawnThatReachedEnd is null.")}var pieceRefForLog=self.findPieceByPosition(self.pawnThatReachedEnd?self.pawnThatReachedEnd.position:"unknown");if(pieceRefForLog){console.log("[Game] Confirmed piece in self.pieces at "+pieceRefForLog.position+" is now type: "+pieceRefForLog.type)}self.isAwaitingPawnPromotion=!1;var callbackToExecute=self.afterPromotionAction;self.pawnThatReachedEnd=null;self.afterPromotionAction=null;if(typeof callbackToExecute==='function'){console.log("[Game] Executing afterPromotionAction (typically completeTurnSequence).");callbackToExecute()}else{console.warn("[Game] No afterPromotionAction callback for "+(self.currentPlayer===self.aiPlayerColor?"AI":"Human")+" promotion. Triggering change manually.");self.triggerChange()}};
        self.moveSelected = function(targetAlgebraicPos){if(self.currentPiece.type=="king"){var kingStartRank=self.currentPiece.color=="white"?0:7;var currentKingCoords=algebraicToCoords(self.currentPiece.position);var targetKingCoords=algebraicToCoords(targetAlgebraicPos);if(currentKingCoords.x==4&&currentKingCoords.y==kingStartRank&&targetKingCoords.y==kingStartRank&&targetKingCoords.x==6){var rookAlgebraicPos=coordsToAlgebraic({x:7,y:kingStartRank});var rook=self.findPieceByPosition(rookAlgebraicPos);if(rook&&rook.type==="rook"&&rook.color===self.currentPiece.color){rook.position=coordsToAlgebraic({x:5,y:kingStartRank})}}}self.currentPiece.position=targetAlgebraicPos;};
        self.takeWithSelected = function(capturedPiece){console.log("[Game] Executing takeWithSelected:",self.currentPiece.type,"takes",capturedPiece.type,"at",capturedPiece.position);self.currentPiece.position=capturedPiece.position;self.pieces=_.without(self.pieces,capturedPiece);if(capturedPiece.color=="black"){self.whiteEated.push(capturedPiece.type)}else{self.blackEated.push(capturedPiece.type)}if(capturedPiece.type==="king"){self.winner=self.currentPlayer;var loserColor=(self.winner==='white')?'black':'white';self.gameOverMessage=self.winner.charAt(0).toUpperCase()+self.winner.slice(1)+" wins by capturing the "+loserColor+" king!";console.log("[Game] King captured! Winner set to:",self.winner)}};
        self.isCheck = function(playerColor){var king=self.findKing(playerColor);if(!king)return!1;var opponentColor=playerColor=="white"?"black":"white";var opponentPieces=_.filter(self.pieces,function(p){return p.color==opponentColor});var boardMap=self.generateCurrentMap();return _.any(opponentPieces,function(opponentPiece){var visibleSquaresForOpponent=self.getVisibles(opponentPiece,boardMap,!0);return _.include(visibleSquaresForOpponent,king.position)})};
        self.getMoves = function(piece, boardMap) {boardMap=boardMap||self.generateCurrentMap();var visibles=self.getVisibles(piece,boardMap);var legalMoves=_.reject(visibles,function(targetPos){var pieceAtTarget=boardMap[targetPos];if(pieceAtTarget&&pieceAtTarget.color===piece.color){return true}return false});return legalMoves;};
        self.isCheckMate = function(playerColor){ return false; }; 
        self.isCheckWithCustomPieces = function(playerColor, customPieceSet){ return false; }; 
        self.isFinished = function(){if(self.winner){ console.log("[Game] isFinished: Game over, winner is", self.winner); return true;} return false;};
        self.findKing = function(playerColor){return _.detect(self.pieces,function(p){return p.type=="king"&&p.color==playerColor})};
        self.findPieceByPosition = function(algebraicPos){return _.detect(self.pieces,function(p){return p.position==algebraicPos})};
        self.generateCurrentMap = function(){var map={};_.each(self.pieces,function(piece){map[piece.position]=piece});return map};
        self.getVisibles = function(piece,boardMap,ignoreKingInPath=!1){boardMap=boardMap||self.generateCurrentMap();var visibleSquares=[];var startCoords=algebraicToCoords(piece.position);var pieceColor=piece.color;var addLineMoves=function(dx,dy){var pathBlocked=!1;for(var i=1;i<8;i++){if(pathBlocked)break;var nextX=startCoords.x+i*dx;var nextY=startCoords.y+i*dy;if(nextX<0||nextX>=8||nextY<0||nextY>=8)break;var targetPos=coordsToAlgebraic({x:nextX,y:nextY});var pieceAtTarget=boardMap[targetPos];if(pieceAtTarget){if(pieceAtTarget.color!=pieceColor){visibleSquares.push(targetPos)}if(!(ignoreKingInPath&&pieceAtTarget.type==='king')){pathBlocked=!0}}else{visibleSquares.push(targetPos)}}};if(piece.type=="rook"||piece.type=="queen"){addLineMoves(1,0);addLineMoves(-1,0);addLineMoves(0,1);addLineMoves(0,-1)}if(piece.type=="bishop"||piece.type=="queen"){addLineMoves(1,1);addLineMoves(1,-1);addLineMoves(-1,1);addLineMoves(-1,-1)}if(piece.type=="knight"){var knightMoves=[{x:1,y:2},{x:1,y:-2},{x:-1,y:2},{x:-1,y:-2},{x:2,y:1},{x:2,y:-1},{x:-2,y:1},{x:-2,y:-1}];_.each(knightMoves,function(move){var nextX=startCoords.x+move.x;var nextY=startCoords.y+move.y;if(nextX>=0&&nextX<8&&nextY>=0&&nextY<8){var targetPos=coordsToAlgebraic({x:nextX,y:nextY});var pieceAtTarget=boardMap[targetPos];if(!pieceAtTarget||pieceAtTarget.color!=pieceColor){visibleSquares.push(targetPos)}}})};if(piece.type=="king"){for(var dx=-1;dx<=1;++dx){for(var dy=-1;dy<=1;++dy){if(dx===0&&dy===0)continue;var nextX=startCoords.x+dx;var nextY=startCoords.y+dy;if(nextX>=0&&nextX<8&&nextY>=0&&nextY<8){var targetPos=coordsToAlgebraic({x:nextX,y:nextY});var pieceAtTarget=boardMap[targetPos];if(!pieceAtTarget||pieceAtTarget.color!=pieceColor){visibleSquares.push(targetPos)}}}}var kingRank=piece.color=="white"?0:7;if(startCoords.x==4&&startCoords.y==kingRank){if(!boardMap[coordsToAlgebraic({x:5,y:kingRank})]&&!boardMap[coordsToAlgebraic({x:6,y:kingRank})]){var rookKingside=boardMap[coordsToAlgebraic({x:7,y:kingRank})];if(rookKingside&&rookKingside.type==='rook'&&rookKingside.color===piece.color){visibleSquares.push(coordsToAlgebraic({x:6,y:kingRank}))}}}};if(piece.type=="pawn"){var direction=(piece.color=="white")?1:-1;var oneStepY=startCoords.y+direction;if(oneStepY>=0&&oneStepY<8){var oneStepPos=coordsToAlgebraic({x:startCoords.x,y:oneStepY});if(!boardMap[oneStepPos]){visibleSquares.push(oneStepPos);var initialRank=(piece.color=="white")?1:6;if(startCoords.y==initialRank){var twoStepsY=startCoords.y+2*direction;var twoStepsPos=coordsToAlgebraic({x:startCoords.x,y:twoStepsY});if(!boardMap[twoStepsPos]){visibleSquares.push(twoStepsPos)}}}}var captureY=startCoords.y+direction;if(captureY>=0&&captureY<8){[-1,1].forEach(function(dx){var captureX=startCoords.x+dx;if(captureX>=0&&captureX<8){var capturePos=coordsToAlgebraic({x:captureX,y:captureY});var pieceAtCapture=boardMap[capturePos];if(pieceAtCapture&&pieceAtCapture.color!=pieceColor){visibleSquares.push(capturePos)}}})}};return _.uniq(visibleSquares);};
    }; // End GameGlobal.Game

})(window.Game = window.Game || {}, window.jQuery || window.Zepto);